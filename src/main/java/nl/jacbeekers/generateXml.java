package nl.jacbeekers;

import org.w3c.dom.*;
import org.xml.sax.InputSource;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamWriter;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import java.io.*;
import java.nio.file.FileAlreadyExistsException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;

import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;
import org.xml.sax.SAXException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class generateXml {

    private static final Logger logger = LogManager.getLogger(generateXml.class.getName());

    static Object lock = new Object();   // lock to synchronize nrRows

    String target = "tryout";
    String xsdFile = "dummy.xsd";
    int nrRows;
    int partNrFiles = 1;
    int nrFiles = 1;
    int nrElements = 0;
    String rootElement = "root";
    HashMap<String, String> entry = null;
    String oneFilePerRow = "N";
    ArrayList<NodeInfo> elementList = new ArrayList<NodeInfo>();
    final String COMPLEX ="xs:complexType";
    final String SIMPLE ="xs:simpleType";

    private void logDebug(String msg) {
        //System.out.println(msg);
        logger.debug(msg);

    }

    private void logWarning(String msg) {
        //System.out.println("WARNING: " +msg);
        logger.warn(msg);
    }

    private void logVerbose(String msg) {
        logger.trace(msg);
    }

    private void failSession(String msg) throws SDKException {
        throw new SDKException(msg);
    }

    public String getTarget() {
        return target;
    }

    public void setTarget(String target) {
        this.target = target;
    }

    public String getXsdFile() {
        return this.xsdFile;
    }

    public void setXsdFile(String xsdFile) {
        this.xsdFile = xsdFile;
    }


    public int getNrRows() {
        return nrRows;
    }

    public void setNrRows(int nrRows) {
        this.nrRows = nrRows;
    }

    ;



    public void generateXmlFile(ArrayList<HashMap<String, String>> data)
            throws SDKException, TransformerException, ParserConfigurationException, SAXException, IOException, XMLStreamException {

        if ("Y".equals(getOneFilePerRow())) {
            generateOneXmlFilePerRow(data);
        }

    }

    public void generateOneXmlFilePerRow(ArrayList<HashMap<String, String>> data)
            throws SDKException, TransformerException, ParserConfigurationException, SAXException {
        for (HashMap<String, String> entry : data) {
            setNrRows(getNrRows() + 1);
            String currentTarget = getTarget() + "_" + getNrRows() + ".xml";
            Path pathXmlFile = Paths.get(currentTarget);
            try {
                Files.createFile(pathXmlFile);
                setEntry(entry);
                writeDataTo(currentTarget);
            } catch (FileAlreadyExistsException e) {
                failSession("xml file already exists: " + e.toString());
            } catch (IOException ioe) {
                failSession("could not create xml file: " + ioe.toString());
            }
        }
    }

    public void generateXmlFileFromFile(String sourceFile)
            throws IOException, XMLStreamException, ParserConfigurationException, SAXException{
        if("N".equals(getOneFilePerRow())) {
            generateOneXmlFile(sourceFile);
        }
    }

    public void generateOneXmlFile(String sourceFile) throws IOException, XMLStreamException, ParserConfigurationException, SAXException {
        //fun
        Date date = new Date();
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String formattedDate = sdf.format(date);
        //input
        File file = new File(sourceFile);
        BufferedReader reader = new BufferedReader(new FileReader(file));
        //xsd
        DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder = docFactory.newDocumentBuilder();
        Document document = builder.parse(new InputSource(new FileReader(
                getXsdFile())));
        //xml
        XMLOutputFactory factory = XMLOutputFactory.newInstance();
        XMLStreamWriter writer = factory.createXMLStreamWriter(new FileOutputStream(getTarget() +".xml"),"UTF-8");

        writer.writeStartDocument("UTF-8", "1.0");
        writer.writeComment("Generated by " + getClass() +" on " + formattedDate);
        writer.writeCharacters("\n");

/*        writer.writeStartElement(getRootElement());
*/
        NodeInfo nodeInfo = new NodeInfo();
        nodeInfo.setAttribute("root");
        nodeInfo.setElementType("root");

        getXsdStructure(document.getDocumentElement(), nodeInfo);
        if(elementList.size() == 1)
            logDebug("elementList contains >" + elementList.size() +"< entry.");
        else
            logDebug("elementList contains >" + elementList.size() +"< entries.");

        outInfoElementList();

        boolean stop = false;
        for(NodeInfo node : elementList) {
            if (node.getElementType() != null) {
                switch (node.getElementType()) {
                    case COMPLEX:
                        writer.writeStartElement(node.getAttribute());
                        break;
                    default:
                        stop=true;
                        break;
                }
            }
            if(stop) break;
        }

        String line;
        int nrLines=0;
        while ((line = reader.readLine()) != null) {
            nrLines++;
            String[] values = line.split(";");
            if(values.length ==1)
                logVerbose("Line >" + nrLines + "< contains >" + values.length +"< field value.");
            else
                logVerbose("Line >" + nrLines + "< contains >" + values.length +"< field values.");
            writer.writeCharacters("\n");
//            writer.writeComment("line >" +nrLines +"<.");
//            writer.writeCharacters("\n");
            int i=0;
            for(NodeInfo node : elementList) {
                if(node.getElementType() != null) {
                    switch(node.getElementType()) {
                        case COMPLEX:
                            break;
                        case SIMPLE:
                            writer.writeStartElement(node.getAttribute());
//                            writer.writeComment("some data here");
                            if(i < values.length) {
                                writer.writeCharacters(values[i]);
                                i++;
                            } else {
                                //more xml elements than data elements
                                logVerbose("There are more xml elements than data fields.");
                            }

                            writer.writeEndElement();
                            break;
                        default:
                            logWarning("Ignored invalid or unsupported elementType >" + node.getElementType() +"<.");
                            break;
                    }
                }
            }

        }

        stop = false;
        boolean wroteEndTime = false;
        for(NodeInfo node : elementList) {
            if (node.getElementType() != null) {
                switch (node.getElementType()) {
                    case COMPLEX:
                        if(!wroteEndTime) {
                            date = new Date();
                            formattedDate = sdf.format(date);
                            writer.writeCharacters("\n");
                            writer.writeComment("Generated by " + getClass() + " completed at " + formattedDate);
                            wroteEndTime=true;
                        }

                        writer.writeEndElement();
                        break;
                    default:
                        stop=true;
                        break;
                }
            }
            if(stop) {
                break;
            }
        }

//        writer.writeEndElement(); //root
        writer.writeEndDocument();
        writer.close();
    }

    public void outInfoElementList() {
        logDebug("xsdStructure contains >" + elementList.size() +"< element(s).");
        int elemNr=0;
        for(NodeInfo elem : elementList) {
            elemNr++;
            logDebug("element# >"+ elemNr +"< is >" +elem.getAttribute() + "< of type >"+
                    elem.getElementType() + "<.");
        }

    }

    public void writeDataTo(String xmlFile)
            throws ParserConfigurationException, IOException, TransformerException, SAXException {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder = factory.newDocumentBuilder();
        Document document = builder.parse(new InputSource(new FileReader(
                getXsdFile())));

        Document outputDoc = builder.newDocument();
        Element outputNode = outputDoc.createElement(getRootElement());

        recurse(document.getDocumentElement(), outputNode, outputDoc);

        TransformerFactory transFactory = TransformerFactory.newInstance();
        Transformer transformer = transFactory.newTransformer();
        StreamResult result = new StreamResult(xmlFile);
        transformer.transform(new DOMSource(outputNode), result);

    }

    public void getXsdStructure(Node node, NodeInfo nodeInfo) {

        if (node.getNodeType() == Node.ELEMENT_NODE) {
            Element element = (Element) node;
            logDebug("nodeName is >" + element.getNodeName() + "<.");
            if ("xs:element".equals(node.getNodeName())) {
                nrElements++;
                logDebug("nrElements is >" + nrElements + "<.");
                try {
                    String attr = element.getAttribute("name");
                    logDebug("attribute >" + attr +"<");
                    NodeInfo newNodeInfo = new NodeInfo();
                    newNodeInfo.setAttribute(attr);
                    NodeList list = element.getChildNodes();
                    for (int i = 0; i < list.getLength(); i++) {
                        logDebug("Child for >" + attr + " is >" + list.item(i).getNodeName() + "<.");
                        if(COMPLEX.equals(list.item(i).getNodeName())) {
                            newNodeInfo.setElementType(COMPLEX);
                        }
                    }
                    //assume
                    if(newNodeInfo.getElementType() == null) {
                        newNodeInfo.setElementType(SIMPLE);
                    }
                    elementList.add(newNodeInfo);
                } catch (DOMException e) {
                    try {
                        String attr = element.getAttribute("ref");
                        logDebug("elementName >" + element.getNodeName() + "< is a ref. NOT SUPPORTED in this release. Ignored.");
                    } catch (DOMException eRef) {
                        logWarning("Ignored element without a name or ref.");
                    }
                }

                // map elements from CSV values here?
            }
            if ("xs:attribute".equals(node.getNodeName())) {
                //TODO required attributes
            }
        }
        NodeList list = node.getChildNodes();
        for (int i = 0; i < list.getLength(); i++) {
            getXsdStructure(list.item(i), nodeInfo);
        }
    }


    public void recurse(Node node, Node outputNode, Document outputDoc) {

        if (node.getNodeType() == Node.ELEMENT_NODE) {
            Element element = (Element) node;
            logDebug("nodeName is >" + element.getNodeName() + "<.");
            if ("xs:element".equals(node.getNodeName())) {
                nrElements++;
                logDebug("nrElements is >" + nrElements + "<.");
                try {
                    String attr = element.getAttribute("name");
                    if (attr.equals(getRootElement()) && nrElements == 1) {
                        logDebug("Ignored rootElement >" + attr + "<. Already created.");
                    } else {
                        Element newElement = outputDoc.createElement(attr);
                        String val = getEntry().get(newElement.getNodeName());
                        newElement.setTextContent(val);
                        logDebug("elementName is >" + newElement.getNodeName() + "<.");
                        logDebug("nodeTextContent is >" + newElement.getTextContent() + "<.");
                        outputNode = outputNode.appendChild(newElement);
                    }
                } catch (DOMException e) {
                    try {
                        String attr = element.getAttribute("ref");
//                        Element newElement = outputDoc.createElement(attr);
                        logDebug("elementName >" + element.getNodeName() + "< is a ref. NOT SUPPORTED in this release. Ignored.");
//                        outputNode = outputNode.appendChild(newElement);
                    } catch (DOMException eRef) {
                        logWarning("Ignored element without a name or ref.");
                    }
                }

                // map elements from CSV values here?
            }
            if ("xs:attribute".equals(node.getNodeName())) {
                //TODO required attributes
            }
        }
        NodeList list = node.getChildNodes();
        for (int i = 0; i < list.getLength(); i++) {
            logVerbose("Processing child node >" + i + "< with name >" +
                    list.item(i).getNodeName() + "<.");
            recurse(list.item(i), outputNode, outputDoc);
        }
    }

    public String getRootElement() {
        return this.rootElement;
    }

    public void setRootElement(String rootElement) {
        this.rootElement = rootElement;
    }

    public String getOneFilePerRow() {
        return oneFilePerRow;
    }

    public void setOneFilePerRow(String oneFilePerRow) {
        this.oneFilePerRow = oneFilePerRow;
    }
    private void setEntry(HashMap<String, String> entry) {
        this.entry = entry;
    }

    private HashMap<String, String> getEntry() {
        return this.entry;
    }


    private void setPartNrFiles(int partNrFiles) {
        this.partNrFiles = partNrFiles;
    }

    public int getPartNrFiles() {
        return this.partNrFiles;
    }

    private void setNrFiles(int nrFiles) {
        this.nrFiles = nrFiles;
    }

    public int getNrFiles() {
        return this.nrFiles;
    }

}

class SDKException extends Exception {
    String msg;

    SDKException(String msg) {
        this.msg = msg;
    }

    public String toString() {
        return ("SDKException occurred: " + this.msg);
    }
}

class NodeInfo {
    String attribute;
    String elementType; // complex?

    public void setAttribute(String attribute) { this.attribute = attribute; }
    public String getAttribute() { return this.attribute; }
    public void setElementType(String elementType) { this.elementType = elementType; }
    public String getElementType() { return this.elementType; }
}